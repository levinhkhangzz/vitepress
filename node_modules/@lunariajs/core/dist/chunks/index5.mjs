import { readFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { readConfig, writeConfig } from '../config/index.mjs';
import { sync as sync$1, error, highlight, bold, select, failure, confirm } from '../cli/console.mjs';
import { isCancel } from '@clack/core';
import 'zod-validation-error';
import '../shared/core.492ac407.mjs';
import 'jiti';
import 'ufo';
import 'zod';
import 'picocolors';
import '../shared/core.ae13c5eb.mjs';

const supportedPackages = ["vitepress", "@astrojs/starlight"];
async function sync(options) {
  if (!options.package)
    console.log(sync$1("Looking for syncable packages..."));
  const configPath = options.config ?? "./lunaria.config.json";
  const skipQuestions = options["skip-questions"] ?? false;
  const selectedPackage = options.package ?? await getPackage();
  if (!selectedPackage) {
    console.error(error("Failed to find your project's packages"));
    process.exit(1);
  }
  switch (selectedPackage) {
    case "vitepress":
      console.log(sync$1(`Syncing with ${highlight("VitePress")}...`));
      const { vitepress } = await import('./vitepress.mjs');
      await vitepress(configPath, skipQuestions);
      break;
    case "@astrojs/starlight":
      console.log(sync$1(`Syncing with ${highlight("Starlight")}...`));
      const { starlight } = await import('./starlight.mjs');
      await starlight(configPath, skipQuestions);
      break;
    default:
      console.error(error(`The selected package ${selectedPackage} is not supported`));
      break;
  }
  console.log(sync$1(bold("Complete!")));
}
async function getPackage() {
  const { dependencies, devDependencies } = loadPackageJson();
  const allPackages = [
    ...dependencies ? Object.keys(dependencies) : [],
    ...devDependencies ? Object.keys(devDependencies) : []
  ];
  const foundPackages = allPackages.filter((pkg) => supportedPackages.includes(pkg));
  if (foundPackages.length < 1) {
    console.log(sync$1("Lunaria currently does not support sync with your project"));
    process.exit(0);
  }
  if (foundPackages.length > 1) {
    const options = foundPackages.map((pkg) => ({ value: pkg }));
    const selected = await select({
      message: sync$1("Found several packages Lunaria can sync with, which do you want to use?"),
      options,
      initialValue: options[0]?.value
    });
    if (isCancel(selected)) {
      console.log(failure("Operation cancelled."));
      process.exit(0);
    }
    return selected;
  }
  return foundPackages[0];
}
function loadPackageJson() {
  const resolvedPath = resolve("./package.json");
  try {
    const packageJson = JSON.parse(readFileSync(resolvedPath, "utf-8"));
    if (!packageJson.dependencies && !packageJson.devDependencies) {
      console.error(
        error("Failed to find a dependencies or devDependencies field in your package.json\n")
      );
      process.exit(1);
    }
    return packageJson;
  } catch (e) {
    console.error(error("Failed to load your package.json\n"));
    throw e;
  }
}
async function updateConfig(configPath, defaultLocale, locales, file, skip) {
  const config = await readConfig(configPath);
  if (defaultLocale) {
    let answer = true;
    if (!skip) {
      const updateDefaultLocale = await confirm({
        message: sync$1("Update defaultLocale?"),
        initialValue: true
      });
      if (isCancel(updateDefaultLocale)) {
        console.log(failure("Operation cancelled."));
        process.exit(0);
      }
      answer = updateDefaultLocale;
    }
    if (answer || skip)
      config.defaultLocale = defaultLocale;
  }
  if (locales) {
    let answer = true;
    if (!skip) {
      const updateLocales = await confirm({
        message: sync$1("Update locales?"),
        initialValue: true
      });
      if (isCancel(updateLocales)) {
        console.log(failure("Operation cancelled."));
        process.exit(0);
      }
      answer = updateLocales;
    }
    if (answer || skip)
      config.locales = locales;
  }
  if (file) {
    let answer = true;
    if (!skip) {
      const updateFiles = await confirm({
        message: sync$1("Update files?"),
        initialValue: true
      });
      if (isCancel(updateFiles)) {
        console.log(failure("Operation cancelled."));
        process.exit(0);
      }
      answer = updateFiles;
    }
    const otherFiles = config.files?.filter((f) => f.location !== file.location) ?? [];
    if (answer || skip)
      config.files = [file, ...otherFiles];
  }
  writeConfig(configPath, config);
}

export { sync, updateConfig };

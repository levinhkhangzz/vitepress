import glob from 'fast-glob';
import micromatch from 'micromatch';
import { resolve, extname, join } from 'node:path';
import { match, compile } from 'path-to-regexp';
import { error, highlight, code } from '../cli/console.mjs';
import { l as loadWithJiti, t as toUtcString, g as getStringFromFormat } from '../shared/core.492ac407.mjs';
import { readFileSync } from 'node:fs';
import { parse } from 'ultramatter';
import { getFileHistory, getGitHostingLinks } from './git.mjs';
import { z } from 'zod';
import '@clack/core';
import 'picocolors';
import 'jiti';
import 'ufo';
import 'node:os';
import 'simple-git';

const frontmatterFile = /\.(yml|md|markdown|mdx|mdoc)$/;
function getFileFrontmatter(path) {
  const resolvedPath = resolve(path);
  try {
    const file = readFileSync(resolvedPath, "utf-8");
    const frontmatter = parse(file).frontmatter;
    return frontmatter;
  } catch (e) {
    console.error(error(`Failed to parse frontmatter from ${highlight(resolvedPath)}
`));
    throw e;
  }
}

async function getDictionaryCompletion(optionalKeys, localizationFilePath, sourceFilePath, sharedPath) {
  const sourceDictionary = await loadDictionary(sourceFilePath);
  const localizationDictionary = await loadDictionary(localizationFilePath);
  const missingKeys = Object.keys(sourceDictionary).flatMap((key) => {
    const isOptionalKey = optionalKeys?.[sharedPath]?.includes(key) === true;
    if (!localizationDictionary.hasOwnProperty(key) && !isOptionalKey)
      return key;
    return [];
  });
  return missingKeys;
}
async function loadDictionary(path) {
  if (frontmatterFile.test(path)) {
    try {
      const file = getFileFrontmatter(path);
      const dictionary = validateDictionary(file);
      return dictionary;
    } catch (e) {
      console.error(error(`Failed to load frontmatter dictionary at ${highlight(path)}
`));
      throw e;
    }
  }
  if (/\.json$/.test(path)) {
    try {
      const resolvedPath = resolve(path);
      const file = readFileSync(resolvedPath, "utf-8");
      const dictionary = validateDictionary(JSON.parse(file));
      return dictionary;
    } catch (e) {
      console.error(error(`Failed to load JSON dictionary at ${highlight(path)}
`));
      throw e;
    }
  }
  if (/\.(c|m)?(js|ts)$/.test(path)) {
    try {
      const file = loadWithJiti(path);
      const dictionary = validateDictionary(file);
      return dictionary;
    } catch (e) {
      console.error(error(`Failed to load JS/TS module dictionary at ${highlight(path)}
`));
      throw e;
    }
  }
  console.error(
    error(
      `Invalid dictionary file type: ${code(
        extname(path)
      )}. Ensure it has one of the valid extensions or track it using ${code(
        'type: "universal"'
      )} instead.`
    )
  );
  process.exit(1);
}
async function validateDictionary(dictionary) {
  const parsedDictionary = DictionaryContentSchema.safeParse(dictionary);
  if (parsedDictionary.success) {
    return parsedDictionary.data;
  }
  console.error(
    error(
      "Invalid dictionary shape, ensure it is a valid recursive Record of strings or track it as a `universal` file type instead."
    )
  );
  process.exit(1);
}

const DictionaryContentSchema = z.record(
  z.string(),
  z.lazy(() => z.string().or(DictionaryContentSchema))
);

async function getLocalizationStatus(config, isShallowRepo) {
  const { defaultLocale, locales, repository } = config;
  const contentIndex = await getFileIndex(config, isShallowRepo);
  const sourceLocaleIndex = contentIndex[defaultLocale.lang];
  if (!sourceLocaleIndex) {
    console.error(
      error(
        "Failed to find the index for the default locale. See if you correctly globbed your content files."
      )
    );
    process.exit(1);
  }
  const gitHostingLinks = getGitHostingLinks(repository);
  const localizationStatus = [];
  for (const sharedPath of Object.keys(sourceLocaleIndex)) {
    const sourceFile = sourceLocaleIndex[sharedPath];
    if (!sourceFile || !sourceFile.isLocalizable)
      continue;
    const localizations = {};
    const fileStatus = {
      sharedPath,
      sourceFile,
      localizations
    };
    for (const { lang } of locales) {
      const pathResolver = getPathResolver(sourceFile.pattern, defaultLocale, locales);
      const localizationFile = contentIndex[lang]?.[sharedPath];
      const localeFilePath = pathResolver.toLocalePath(sourceFile.path, lang);
      switch (localizationFile?.meta.type) {
        case void 0: {
          localizations[lang] = {
            isMissing: true,
            gitHostingFileURL: gitHostingLinks.create(localeFilePath),
            gitHostingHistoryURL: gitHostingLinks.history(
              sourceFile.path,
              sourceFile.git.lastMajorChange
            )
          };
          break;
        }
        case "universal": {
          localizations[lang] = {
            ...localizationFile,
            isMissing: false,
            isOutdated: sourceFile.git.lastMajorChange > localizationFile.git.lastMajorChange,
            gitHostingHistoryURL: gitHostingLinks.history(
              sourceFile.path,
              sourceFile.git.lastMajorChange
            ),
            meta: {
              type: "universal"
            }
          };
          break;
        }
        case "dictionary": {
          localizations[lang] = {
            ...localizationFile,
            isMissing: false,
            isOutdated: sourceFile.git.lastMajorChange > localizationFile.git.lastMajorChange,
            gitHostingHistoryURL: gitHostingLinks.history(
              sourceFile.path,
              sourceFile.git.lastMajorChange
            ),
            meta: {
              type: "dictionary",
              missingKeys: await getDictionaryCompletion(
                sourceFile.meta.type === "dictionary" ? sourceFile.meta.optionalKeys : void 0,
                localizationFile.path,
                sourceFile.path,
                sharedPath
              )
            }
          };
        }
      }
    }
    localizationStatus.push(fileStatus);
  }
  return localizationStatus;
}
async function getFileIndex(config, isShallowRepo) {
  const { files, defaultLocale, locales, localizableProperty, ignoreKeywords, repository } = config;
  const contentIndex = {};
  for (const file of files) {
    const { location, ignore, pattern } = file;
    const pathResolver = getPathResolver(pattern, defaultLocale, locales);
    const contentPaths = await glob(location, {
      cwd: process.cwd(),
      ignore: ["node_modules", ...ignore]
    });
    const filesData = await Promise.all(
      contentPaths.sort().map(async (path) => {
        const params = pathResolver.isMatch(path).params;
        if (!params) {
          console.error(
            error(
              `Failed to extract path params from pattern ${highlight(pattern)}. Is there a typo?`
            )
          );
          process.exit(1);
        }
        const lang = params.lang || defaultLocale.lang;
        const isSourceLocale = lang === defaultLocale.lang;
        const sharedPath = pathResolver.toSharedPath(path);
        const gitHostingLinks = getGitHostingLinks(repository);
        const gitHostingFileURL = gitHostingLinks.source(path);
        const gitHostingHistoryURL = gitHostingLinks.history(path);
        const fileData = await getFileData(
          path,
          isSourceLocale,
          isShallowRepo,
          repository.rootDir,
          localizableProperty,
          ignoreKeywords
        );
        const meta = {
          type: file.type,
          ...file.type === "dictionary" && { optionalKeys: file.optionalKeys }
        };
        return {
          lang,
          sharedPath,
          ...fileData,
          gitHostingFileURL,
          gitHostingHistoryURL,
          pattern,
          meta
        };
      })
    );
    filesData.forEach((data) => {
      const { lang, sharedPath } = data;
      contentIndex[lang] = {
        ...contentIndex[lang],
        [sharedPath]: data
      };
    });
  }
  return contentIndex;
}
async function getFileData(filePath, isSourceLocale, isShallowRepo, rootDir, localizableProperty, ignoreKeywords) {
  const monorepoSafePath = isShallowRepo ? join(rootDir, filePath) : filePath;
  const historyData = await getFileHistory(monorepoSafePath);
  const allCommits = historyData.all;
  const lastCommit = historyData.latest;
  if (!lastCommit || !allCommits) {
    console.error(
      error(
        `Failed to retrieve last commit data from ${resolve(
          monorepoSafePath
        )}. Your working copy should not contain uncommitted changes to tracked files when running Lunaria. This might also happen when developing locally on a monorepo without the ${code(
          "repository.rootDir"
        )} option set.`
      )
    );
    process.exit(1);
  }
  const lastMajorCommit = findLastMajorCommit(filePath, allCommits, ignoreKeywords) || lastCommit;
  return {
    path: filePath,
    isLocalizable: await isLocalizable(filePath, localizableProperty, isSourceLocale),
    git: {
      lastChange: toUtcString(lastCommit.date),
      lastCommitMessage: lastCommit.message,
      lastMajorChange: toUtcString(lastMajorCommit.date),
      lastMajorCommitMessage: lastMajorCommit.message
    }
  };
}
function getPathResolver(pattern, defaultLocale, locales) {
  const langs = [defaultLocale, ...locales].map(({ lang }) => lang);
  const localesPartial = langs.join("|");
  const langPattern = `:lang(${localesPartial})?`;
  const langPatternDir = `{:lang(${localesPartial})/}?`;
  const pathPattern = ":path(.*)";
  const augmentedPattern = getStringFromFormat(pattern, {
    "@locales": localesPartial,
    "@lang/": langPatternDir,
    "@lang": langPattern,
    "@path": pathPattern
  });
  const matcher = match(augmentedPattern);
  const toPath = compile(augmentedPattern);
  const getParams = (path) => {
    return matcher(path).params;
  };
  return {
    isMatch: matcher,
    toLocalePath: (path, lang) => {
      return toPath({
        path: getParams(path).path,
        lang
      });
    },
    toSharedPath: (path) => {
      return toPath({
        path: getParams(path).path
      });
    }
  };
}
function findLastMajorCommit(filePath, allCommits, ignoreKeywords) {
  const TRACKER_DIRECTIVES = /(?<directive>@tracker-major|@lunaria-track|@tracker-minor|@lunaria-ignore):(?<pathsOrGlobs>[^\n]+)?/;
  const IGNORE_KEYWORDS = new RegExp(`(${ignoreKeywords.join("|")})`, "i");
  return allCommits.find((entry) => {
    if (entry.message.match(IGNORE_KEYWORDS))
      return false;
    const trackerDirectiveMatch = entry.body.match(TRACKER_DIRECTIVES);
    if (!trackerDirectiveMatch || !trackerDirectiveMatch.groups)
      return true;
    const { directive, pathsOrGlobs } = trackerDirectiveMatch.groups;
    const pathsOrGlobsList = pathsOrGlobs.split(";");
    return pathsOrGlobsList.find((pathOrGlob) => {
      if (directive === "@lunaria-track" || directive === "@tracker-major")
        return micromatch.isMatch(filePath, pathOrGlob);
      if (directive === "@lunaria-ignore" || directive === "@tracker-minor")
        return !micromatch.isMatch(filePath, pathOrGlob);
    }) !== void 0;
  });
}
async function isLocalizable(filePath, localizableProperty, isSourceLocale) {
  if (!isSourceLocale || !localizableProperty)
    return true;
  if (!frontmatterFile.test(filePath))
    return true;
  const frontmatter = getFileFrontmatter(filePath);
  const isLocalizable2 = frontmatter?.[localizableProperty];
  if (typeof isLocalizable2 === "undefined")
    return false;
  if (typeof isLocalizable2 !== "boolean") {
    console.error(
      error(
        `The specified frontmatter property ${localizableProperty} was found with an non-boolean value in ${filePath}. Ensure that all of its occurances are either as \`true\` or \`false\`.`
      )
    );
    process.exit(1);
  }
  return isLocalizable2;
}

export { DictionaryContentSchema, getLocalizationStatus, getPathResolver };

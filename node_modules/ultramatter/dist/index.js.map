{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["function split(input: string): [string, string] {\n  let match = 0;\n  let state: \"open\" | \"closed\" | \"default\" = \"default\";\n  let locs: number[] = [];\n  for (let i = 0; i < input.length; i++) {\n    const c = input[i];\n    if (c === \"-\") {\n      if (match === 0) {\n        if (\n          (state === \"default\" && i == 0) ||\n          (state === \"open\" && input[i - 1] === \"\\n\")\n        ) {\n          match = 1;\n        } else {\n          continue;\n        }\n      } else {\n        match++;\n      }\n    } else {\n      match = 0;\n    }\n    if (match === 3) {\n      state = state === \"default\" ? \"open\" : \"closed\";\n      locs.push(i + 1);\n    }\n  }\n  switch (state) {\n    case \"default\":\n      return [\"\", input];\n    case \"open\":\n      return [\"\", input];\n    case \"closed\":\n      return [\n        input.slice(locs[0], locs[1] - 3).trim(),\n        input.slice(locs[1]).trimStart(),\n      ];\n  }\n}\n\nconst getIndent = (value: string) =>\n  value.slice(0, value.length - value.trimStart().length);\nconst dedent = (value: string) => {\n  const indent = getIndent(value);\n  return value\n    .split(\"\\n\")\n    .map((ln) => ln.slice(indent.length))\n    .join(\"\\n\");\n};\nconst unquote = (value: string) => {\n  if (value[0] === '\"' || value[0] === \"'\") {\n    const quote = value[0];\n    if (value[value.length - 1] === quote) {\n      return value.slice(1, -1);\n    }\n  }\n  return value;\n}\nconst coerce = (value: string) => {\n  if (value === 'true' || value === 'false') return value === 'true';\n  if (!Number.isNaN(Number(value))) return Number(value);\n  return unquote(value);\n}\n\nconst yaml = (input: string): any => {\n  const YAML_OBJECT_RE = /(^[^\\:\\s]+):(?!\\/)\\n?([\\s\\S]*?(?=^\\S)|[\\s\\S]*$)/gm;\n  const YAML_TOKENS_RE = /[\\:\\-\\[\\]\\|\\#]/gm;\n  const YAML_COMMENT_RE = /#.*$/gm;\n\n  const indent = getIndent(input);\n  if (!YAML_TOKENS_RE.test(input)) {\n    if (indent.length > 1) {\n      return dedent(input)\n    } else {\n      return coerce(input.trim())\n    }\n  }\n  if (indent.length <= 1) {\n    input = input.trimStart();\n  }\n\n  let block;\n  let obj: Record<string, any> = {};\n  while ((block = YAML_OBJECT_RE.exec(input))) {\n    let [_, key, value] = block;\n    const indent = getIndent(value);\n    if (indent.length > 1) {\n      const lines = dedent(value);\n      obj[key] = yaml(lines);\n    } else {\n      obj[key] = yaml(value);\n    }\n  }\n  if (Object.keys(obj).length > 0) {\n    return obj;\n  }\n  \n  let value = input.trim().replace(YAML_COMMENT_RE, '').trim();\n  if (value.startsWith('-')) {\n    const items = value.split(/^\\-/gm).filter(v => v).map(v => yaml(v.trimEnd()))\n    return items;\n  } else if (value.startsWith(\"[\")) {\n    value = value.slice(1, -1);\n    return value.split(\",\").map((v) => coerce(v.trim()));\n  } else if (value.startsWith(\"|\")) {\n    return dedent(value.replace(\"|\", \"\").replace(\"\\n\", \"\"));\n  } else {\n    return coerce(value.trim());\n  }\n};\n\nexport interface Result {\n  frontmatter?: Record<string, any>;\n  content: string;\n}\n\nexport function parse(input: string): Result {\n  const [raw, content] = split(input);\n\n  if (raw) {\n    return {\n      frontmatter: yaml(raw),\n      content,\n    };\n  }\n\n  return {\n    content,\n  };\n}\n"],
  "mappings": "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",
  "names": ["split", "input", "match", "state", "locs", "i", "getIndent", "value", "dedent", "indent", "ln", "unquote", "quote", "coerce", "yaml", "YAML_OBJECT_RE", "YAML_TOKENS_RE", "YAML_COMMENT_RE", "block", "obj", "_", "key", "lines", "v", "parse", "raw", "content"]
}
